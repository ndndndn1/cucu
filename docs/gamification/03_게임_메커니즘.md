# 03. 게임 메커니즘

> 9-섹션 퀘스트 체인, 6가지 게임 유형(A-F), 10개 시뮬레이션 게임화, 3개 보스전 설계.

---

## 1. 9-섹션 퀘스트 체인

기존 교육 모듈의 9개 섹션(`## 1.` ~ `## 9.`) 구조를 그대로 유지하면서, 각 섹션에 게임 래퍼를 씌운다. 기존 Markdown 콘텐츠는 변경하지 않으며, 웹앱이 H2 헤더를 파싱하여 게임 요소를 동적으로 삽입한다.

| 섹션 | 기존 제목 | 게임 래퍼 | 게임 유형 | FC 보상 |
|------|---------|---------|---------|--------|
| 1 | 학습 목표 | **미션 브리핑** | (비게임) | — |
| 2 | 사전 복습 | **기억력 챌린지** | 게임 A | 30-50 |
| 3 | 개념 설명 | **개념 매칭** | 게임 B | 20 |
| 4 | 코드 분석 | **코드 추적** | 게임 C | 0-30 |
| 5 | 왜 이것이 작동하는가? | **주니어에게 설명하기** | 게임 D | 40/문항 |
| 6 | 시뮬레이션 | **인터랙티브 시뮬레이션** | 게임 E | 50-150 |
| 7 | 핵심 정리 | **핵심 하이라이트** | (선택) | 15 |
| 8 | 퀴즈 / 마스터리 | **최적화 챌린지 / 보스전** | 게임 F | 가변 |
| 9 | 다음 단계 미리보기 | **다음 미션 인텔** | (비게임) | — |

### 섹션 간 진행 규칙

- 섹션 1-7은 **순차 진행** (이전 섹션 완료 후 다음 해금)
- 섹션 8(퀴즈)은 **섹션 1-7 모두 완료 후** 해금
- 섹션 9는 **섹션 8 통과(60%+) 후** 해금
- 마스터리 체크포인트(모듈 06, 08, 09)는 **80%+ 통과 필수**

---

## 2. 게임 유형 상세

### 게임 A: 기억력 챌린지 (섹션 2 — 사전 복습)

**목적**: 이전 모듈 내용의 인출 연습(Retrieval Practice)을 게임화

**규칙**:
1. 이전 1-2개 모듈에서 추출된 3개 질문이 순서대로 표시
2. 총 60초 타이머 작동
3. 각 질문에 대해 4지선다 또는 단답형으로 응답
4. 30초 이내에 3문항 모두 정답 시 스피드 보너스 (+20 FC)

**보상 구조**:

| 결과 | FC |
|------|-----|
| 3문항 완료 (정오 무관) | 30 |
| 30초 내 3문항 전부 정답 | +20 (보너스) |
| **최대** | **50** |

**UI 요소**:
- 상단: 60초 카운트다운 타이머 (30초 지점에서 색상 변화)
- 중앙: 질문 카드 (넘기기 애니메이션)
- 하단: 정답/오답 즉시 피드백 + 관련 모듈 링크

**적용 모듈**: 01-10 (모듈 00은 사전 복습 없음) — 총 10개 세트, 30문항

---

### 게임 B: 개념 매칭 (섹션 3 — 개념 설명)

**목적**: CRA 프레임워크(일상 비유 → 다이어그램 → 수식)의 세 표현 간 연결을 능동적으로 구축

**규칙**:
1. 해당 모듈의 핵심 개념 3-5개가 세 가지 표현으로 분리되어 카드로 제시
   - **비유 카드**: 일상적 비유 (예: "도서관 책 정렬")
   - **다이어그램 카드**: 시각적 표현 (ASCII 다이어그램 또는 이미지)
   - **수식/정의 카드**: 수학적 수식 또는 기술적 정의
2. 학생이 드래그앤드롭으로 같은 개념의 세 카드를 매칭
3. 전부 올바르게 매칭하면 완료

**보상**: 20 FC (완료 시)

**예시 (모듈 05 — 메모리 코얼레싱)**:

| 개념 | 비유 | 다이어그램 | 수식/정의 |
|------|------|----------|----------|
| 코얼레싱 | "한 줄로 서서 순서대로 책 빌리기" | 워프 32스레드 → 128B 트랜잭션 그림 | `float4` 128-bit aligned load |
| 스트라이드 접근 | "한 칸 건너 앉기" | 메모리 주소 스킵 패턴 | `A[threadIdx.x * stride]` |
| 대역폭 활용률 | "고속도로 차선 활용률" | 활용/낭비 바 차트 | `utilized_bytes / requested_bytes` |

**적용 모듈**: 00-10 — 총 11개 세트

---

### 게임 C: 코드 추적 (섹션 4 — 코드 분석)

**목적**: Worked Example의 능동적 참여를 유도 — 학생이 코드를 직접 "실행"

**규칙**:
1. 해당 모듈의 핵심 코드 스니펫이 단계별로 표시
2. 각 단계에서 특정 변수의 값을 예측하도록 질문
3. 연속 정답 시 콤보 카운터 증가 (시각적 피드백)
4. 5연속 정답 달성 시 콤보 보너스

**보상 구조**:

| 결과 | FC |
|------|-----|
| 단계 완료 (기본) | 0 |
| 5연속 정답 콤보 | 30 |
| 10연속 정답 콤보 | +30 (추가) |

**예시 (모듈 04 — 나이브 SGEMM)**:

```
스텝 1: row = blockIdx.y * blockDim.y + threadIdx.y
        blockIdx.y=2, blockDim.y=16, threadIdx.y=5일 때, row = ?
        정답: 37

스텝 2: col = blockIdx.x * blockDim.x + threadIdx.x
        blockIdx.x=1, blockDim.x=16, threadIdx.x=10일 때, col = ?
        정답: 26

스텝 3: A[row * K + k]에서 row=37, K=64, k=3일 때 인덱스 = ?
        정답: 2371
```

**적용 모듈**: 04-09 (코드 분석이 있는 모듈) — 총 6-7개 세트

---

### 게임 D: 주니어에게 설명하기 (섹션 5 — 왜 이것이 작동하는가?)

**목적**: 정교화 질문(Elaborative Interrogation)을 teach-back 형식으로 전환

**규칙**:
1. 해당 모듈의 "왜 작동하는가?" 질문이 표시 (모듈당 3-5개)
2. 시나리오: "신입 후배가 이 질문을 했습니다. 설명해주세요."
3. 학생이 텍스트 입력으로 답변
4. 키워드 기반 검증: 답변에 필수 키워드가 포함되어 있는지 확인
5. 필수 키워드 3개 중 2개 이상 포함 시 통과

**보상**: 40 FC/문항 (통과 시)

**키워드 검증 예시 (모듈 06 — 공유 메모리)**:

| 질문 | 필수 키워드 (3개 중 2개) |
|------|----------------------|
| "왜 공유 메모리를 사용하면 빨라지는가?" | `재사용`, `글로벌 메모리`, `대역폭` |
| "왜 +1 패딩이 뱅크 충돌을 해결하는가?" | `뱅크`, `32`, `오프셋` (또는 `패딩`) |
| "타일 크기는 왜 128×128인가?" | `공유 메모리`, `점유율`, `SM` |

**적용 모듈**: 04-10 (총 ~40문항)

---

### 게임 E: 인터랙티브 시뮬레이션 (섹션 6)

기존 종이/스프레드시트 기반 시뮬레이션 10개를 웹 기반 인터랙티브로 변환한다. 상세는 [섹션 3: 10개 시뮬레이션 게임화](#3-10개-시뮬레이션-게임화)에서 기술한다.

---

### 게임 F: 최적화 챌린지 (섹션 8 — 퀴즈)

**목적**: 숙달 학습(Mastery Learning) 게이트 퀴즈를 성과 기반 게임으로 전환

**규칙**:
1. 해당 모듈의 퀴즈 문항이 순서대로 표시 (모듈당 5-10문항)
2. 연속 정답 시 콤보 배율 증가:
   - 1-2연속: ×1 배율
   - 3-4연속: ×1.5 배율
   - 5-6연속: ×2 배율
   - 7+연속: ×3 배율
3. 오답 시 콤보 리셋 (배율 ×1로 복귀), 학습 피드백 표시
4. GFLOP/s 미터가 실시간으로 상승 (정답률에 비례)
5. 마스터리 체크포인트에서는 80%+ 통과 필수

**보상 구조**:

| 항목 | FC |
|------|-----|
| 1차 시도 정답 | 20 × 콤보배율 |
| 2차 시도 정답 | 10 |
| 3차+ 시도 정답 | 5 |
| 만점 보너스 | 100 |

**콤보 배율 예시** (8문항 모듈, 전문항 1차 정답):

```
Q1: 20 × 1.0 = 20
Q2: 20 × 1.0 = 40  (누적 40)
Q3: 20 × 1.5 = 30  (누적 70)
Q4: 20 × 1.5 = 30  (누적 100)
Q5: 20 × 2.0 = 40  (누적 140)
Q6: 20 × 2.0 = 40  (누적 180)
Q7: 20 × 3.0 = 60  (누적 240)
Q8: 20 × 3.0 = 60  (누적 300)
+ 만점 보너스:      100
총합:               400 FC
```

**GFLOP/s 미터**:
- 현재 모듈의 최적화 레벨에 해당하는 GFLOP/s 범위를 미터로 표시
- 정답률에 비례하여 미터가 상승
- 예: 모듈 07 (Level 3) → 미터 범위 2,000-3,000 GFLOP/s, 만점 시 3,000 도달

**Bloom 레벨 표시**: 각 문항 옆에 Bloom 인지 수준 아이콘 표시
- 기억 (💭), 이해 (📖), 적용 (🔧), 분석 (🔍), 평가 (⚖️), 창조 (🏗️)

---

## 3. 10개 시뮬레이션 게임화

기존 종이/스프레드시트 시뮬레이션을 웹 기반 인터랙티브로 전환하되, 학습 목표와 절차는 동일하게 유지한다.

### 시뮬레이션 1: Thread-to-Hardware 매핑 (모듈 01)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 계산/표 작성 |
| **인터랙티브** | 드래그앤드롭 — 스레드 블록을 SM 슬롯에 배치 |
| **시나리오** | Grid(4,4) / Block(256) → 16개 블록을 4개 SM에 할당 |
| **검증** | 블록 분배 균형 확인, 웨이브 수 계산 |
| **보너스** | 점유율(occupancy) 최적 분배 달성 시 +50 FC |
| **최대 FC** | 100 |

### 시뮬레이션 2: Driver API 호출 시퀀스 (모듈 02)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 플로우차트 |
| **인터랙티브** | 카드 순서 정렬 퍼즐 — API 호출 카드를 올바른 순서로 배치 |
| **카드** | `cuInit`, `cuDeviceGet`, `cuCtxCreate`, `cuModuleLoad`, `cuMemAlloc`, `cuMemcpyHtoD`, `cuLaunchKernel`, `cuMemcpyDtoH`, `cuMemFree`, `cuCtxDestroy` |
| **검증** | 의존성 순서 정확성, 리소스 생명주기 올바름 |
| **최대 FC** | 100 |

### 시뮬레이션 3: FLOP 계산기 (모듈 03)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 스프레드시트 계산 |
| **인터랙티브** | 입력 폼 + 검증기 — 5개 시나리오의 FLOP, 메모리 전송량, 산술 강도 계산 |
| **시나리오** | M×N×K 조합 5가지 (256², 512², 1024², 2048², 4096²) |
| **스피드 모드** | 5개 시나리오 모두 2분 이내 정답 시 +50 FC |
| **최대 FC** | 100 |

### 시뮬레이션 4: 메모리 접근 패턴 시각화 (모듈 04)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 시각화 (종이) |
| **인터랙티브** | 캐시라인 접근 그리드 페인팅 — 워프의 32스레드가 접근하는 메모리 주소를 그리드에 색칠 |
| **시나리오** | 행 우선 vs 열 우선 접근, 연속 vs 스트라이드 |
| **검증** | 접근 패턴의 캐시라인 수 계산 정확성 |
| **최대 FC** | 120 |

### 시뮬레이션 5: 코얼레싱 패턴 검사기 (모듈 05)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 패턴 분석 |
| **인터랙티브** | 주소 시각화 + 트랜잭션 최소화 게임 |
| **시나리오** | 주어진 접근 패턴에서 메모리 트랜잭션 수를 최소화하도록 인덱싱 수정 |
| **검증** | 트랜잭션 수 계산, 코얼레싱 비율 측정 |
| **최대 FC** | 120 |

### 시뮬레이션 6: 뱅크 충돌 검출기 (모듈 06)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 검출 (종이) |
| **인터랙티브** | 패딩 토글 + 실시간 뱅크 충돌 시각화 |
| **시나리오** | 32×32 공유 메모리 배열의 뱅크 할당 시각화, 접근 시 충돌 하이라이트 |
| **조작** | +1 패딩 토글, 접근 패턴 변경, 충돌 수 실시간 표시 |
| **보스전 연계** | "뱅크 충돌 수호자" 보스전의 사전 연습 |
| **최대 FC** | 150 |

### 시뮬레이션 7: 외적 연산 추적기 (모듈 07)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 연산 추적 |
| **인터랙티브** | 결과 행렬 단계별 채우기 + 레지스터 재사용 카운터 |
| **시나리오** | 8×8 스레드 타일의 외적 연산을 단계별로 추적, 각 FMA가 어떤 레지스터를 재사용하는지 시각화 |
| **검증** | k-반복 후 결과 행렬 값 정확성, 레지스터 로드 횟수 계산 |
| **최대 FC** | 150 |

### 시뮬레이션 8: 파이프라인 타임라인 (모듈 08)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 타임라인 (종이) |
| **인터랙티브** | 간트 차트에 로드/연산 블록 배치 |
| **시나리오** | 싱글 버퍼 → 더블 버퍼 타임라인 구축, 사이클 수 비교 |
| **조작** | 로드 블록과 연산 블록을 타임라인에 드래그, 동시 실행 가능 여부 자동 판정 |
| **검증** | 총 사이클 수 계산, 숨겨진 레이턴시 비율 |
| **최대 FC** | 150 |

### 시뮬레이션 9: 비동기 파이프라인 상태 기계 (모듈 09)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 상태 기계 |
| **인터랙티브** | commit/wait 컨트롤로 트리플 버퍼 상태를 스텝스루 |
| **시나리오** | 3개 버퍼의 상태 (empty/loading/ready/computing)를 단계별로 추적 |
| **조작** | `cp.async.commit_group`, `cp.async.wait_group<N>` 명령 발행 |
| **검증** | 각 단계에서 버퍼 상태 정확성, 데이터 해저드 감지 |
| **최대 FC** | 150 |

### 시뮬레이션 10: 프로파일 데이터 해석 (모듈 10)

| 항목 | 내용 |
|------|------|
| **기존 형태** | 데이터 분석 |
| **인터랙티브** | "이 커널은 어떤 최적화 레벨?" 탐정 게임 |
| **시나리오** | 5개 가상 프로파일 데이터셋 (Nsight Compute 형태), 각각 어떤 레벨의 커널인지 식별 |
| **단서** | 메모리 처리량, 연산 처리량, SM 점유율, 캐시 적중률 등 |
| **검증** | 레벨 식별 정확성 + 근거 키워드 |
| **최대 FC** | 150 |

### 시뮬레이션 FC 합계

| 시뮬레이션 | 최대 FC |
|-----------|--------|
| #1-3 | 300 |
| #4-5 | 240 |
| #6-10 | 750 |
| **합계** | **1,290** |

> **참고**: 경제 시스템(02 문서)의 시뮬레이션 FC 추정치(10 × 150 = 1,500)는 상한 기준이다. 실제 최대 합계는 1,290이며, 정확도에 따라 50-150 범위에서 지급된다.

---

## 4. 보스전 (마스터리 체크포인트)

3개 마스터리 체크포인트(모듈 06, 08, 09)를 다단계 보스전으로 연출한다.

### 보스전 1: "뱅크 충돌 수호자" (모듈 06 — 마스터리 체크포인트 1)

**배경**: SiliconForge의 공유 메모리 서브시스템에 뱅크 충돌 버그가 발생. 아키텍트가 나서서 해결해야 한다.

**3단계 구성**:

| 단계 | 과제 | 통과 조건 |
|------|------|---------|
| 1단계: 식별 | 새로운 공유 메모리 레이아웃(기존 시뮬레이션과 다른 배열)에서 뱅크 충돌 위치 표시 | 충돌 지점 80%+ 정확 식별 |
| 2단계: 해결 | 패딩 크기와 위치를 제안하여 충돌 제거 | 제안한 패딩이 실제로 충돌을 0으로 감소 |
| 3단계: 검증 | 수정된 레이아웃의 뱅크 할당을 계산하여 충돌 없음을 증명 | 계산 정확성 100% |

**보상**: 통과 300 FC + SC 5 (만점 시 SC 10)

---

### 보스전 2: "레이턴시 드래곤" (모듈 08 — 마스터리 체크포인트 2)

**배경**: 프로젝트 Titan의 파이프라인에 레이턴시 스톨이 발생. 싱글 버퍼에서 더블 버퍼로 전환하여 성능을 2배로 끌어올려야 한다.

**3단계 구성**:

| 단계 | 과제 | 통과 조건 |
|------|------|---------|
| 1단계: 분석 | 주어진 싱글 버퍼 타임라인에서 스톨 구간 식별 | 스톨 구간 정확히 표시 |
| 2단계: 변환 | 동일한 워크로드를 더블 버퍼 타임라인으로 재배치 | 총 사이클 수 30%+ 감소 |
| 3단계: 진단 | Long Scoreboard 스톨 사례를 분석하고 원인-결과 매칭 | 3개 사례 중 2개+ 정확 |

**보상**: 통과 300 FC + SC 5 (만점 시 SC 10)

---

### 보스전 3: "최종 벤치마크" (모듈 09 — 최종 마스터리 체크포인트)

**배경**: SiliconForge 경영진에게 최종 성능 보고서를 발표해야 한다. cuBLAS 대비 성능을 분석하고, 잔여 갭의 원인을 설명하며, 다음 세대 개선안을 제시하라.

**3단계 구성**:

| 단계 | 과제 | 통과 조건 |
|------|------|---------|
| 1단계: 해석 | 가상 프로파일 데이터 (L5 커널 vs cuBLAS)에서 성능 병목 식별 | 주요 병목 3개 중 2개+ 식별 |
| 2단계: 설명 | 잔여 성능 갭(5-15%)의 원인을 Bloom "평가" 수준으로 설명 | 필수 키워드 포함 서술 |
| 3단계: 설계 | 성능 갭을 줄이기 위한 개선안 1개를 구체적으로 설계 | 기술적 실현 가능성 검증 통과 |

**보상**: 통과 300 FC + SC 10 (만점 시 SC 15)

---

## 5. 보스전 공통 규칙

1. **80% 통과 필수**: 보스전을 통과하지 못하면 다음 모듈로 진행 불가
2. **재시도 가능**: 실패 시 즉시 재시도 가능, 재시도 시에도 FC 보상 동일 (SC는 1차 만점만)
3. **실패 피드백**: 단계별 상세 피드백 + 관련 섹션 복습 링크
4. **시간 제한 없음**: 보스전에는 타이머가 없으며, 충분히 생각하고 답변할 수 있음
5. **부분 점수**: 각 단계는 독립적으로 채점, 일부 단계만 통과해도 부분 FC 지급

---

## 6. 게임 메커니즘 요약 — 전체 모듈 매핑

| 모듈 | 게임A | 게임B | 게임C | 게임D | 게임E | 게임F | 보스전 |
|------|-------|-------|-------|-------|-------|-------|--------|
| 00 | — | O | — | — | — | — | — |
| 01 | O | O | — | — | Sim1 | 퀴즈 | — |
| 02 | O | O | — | — | Sim2 | 퀴즈 | — |
| 03 | O | O | — | — | Sim3 | 퀴즈 | — |
| 04 | O | O | O | O | Sim4 | 퀴즈 | — |
| 05 | O | O | O | O | Sim5 | 퀴즈 | — |
| 06 | O | O | O | O | Sim6 | 마스터리 | 뱅크충돌수호자 |
| 07 | O | O | O | O | Sim7 | 퀴즈 | — |
| 08 | O | O | O | O | Sim8 | 마스터리 | 레이턴시드래곤 |
| 09 | O | O | O | O | Sim9 | 마스터리 | 최종벤치마크 |
| 10 | O | O | O | O | Sim10 | 퀴즈 | — |
